# **ТЗ на проект "Сервер картинок 2.0"**

## **0. Организация работы над проектом**

Встречи и разработка:
- У тебя будет 3 занятия с ментором, где вы вместе разберете важные части проекта.
- Ментор поможет определить комфортный дедлайн для завершения работы.
- Основной функционал вы напишете вместе на консультациях. 

[**1. Введение**](#1-введение)  
[**2. Дополнительный функционал**](#2-дополнительный-функционал)  
[**3. Обновленная структура проекта**](#3-обновленная-структура-проекта)  
[**4. Технические задачи**](#4-технические-задачи)  
[**5. Подключение базы данных**](#5-подключение-базы-данных)  


## **1. Введение**

Вы уже изучили работу с базами данных и SQL. 
Настало время закрепить эти знания на практике.
Вот что вам предстоит делать: 

1. Добавить в backend работу с базой данных.
2. Немного расширить функциональность нашего веб-сервиса:
   - добавление страницы списка изображений;
   - удаление изображений;
   - пагинация списка изображений.
3. Резервное копирование данных из БД.


## **2. Дополнительный функционал**

### **1. Хранение метаданных об изображениях в базе данных**

**Описание:**

- После загрузки изображения Python-бэкенд сохраняет метаданные в PostgreSQL:
  - уникальный идентификатор изображения;
  - сгенерированное имя файла;
  - оригинальное имя файла от пользователя;
  - размер файла в байтах;
  - дата и время загрузки;
  - формат файла.

**Требования:**

- cоздать таблицу `images` в PostgreSQL:

  ```sql
  CREATE TABLE images (
      id SERIAL PRIMARY KEY,
      filename TEXT NOT NULL,
      original_name TEXT NOT NULL,
      size INTEGER NOT NULL,
      upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      file_type TEXT NOT NULL
  );
  ```
  
- при каждом успешном сохранении файла в папку `/images`, 
соответствующие метаданные должны быть добавлены в базу данных;

- метаданные доступны для чтения и использования в других функциях (например, для списка изображений).

### **2. Добавление страницы списка изображений**

**Описание:**

- на странице `/images-list` отображён список всех загруженных изображений.
- информация для каждого изображения включает:
 - имя файла со ссылкой для просмотра/загрузки;
 - оригинальное имя файла;
 - размер файла в КБ;
 - дату и время загрузки;
 - тип файла.

**Требования:**

- реализовать Python-бэкенд маршрут `/images-list` с методом `GET` для получения данных из PostgreSQL;
- создать структурированную веб-страницу с таблицей или списком изображений, используя HTML и CSS;
- добавить для каждого изображения ссылку на файл по пути `/images/<имя_файла>`.

**Пример отображения:**

| Имя файла  | Оригинальное имя | Размер (КБ) | Дата загрузки       | Тип файла |
| ---------- | ---------------- | ----------- | ------------------- | --------- |
| `img1.jpg` | `photo1.jpg`     | 120         | 2025-01-24 15:30:00 | jpg       |
| `img2.png` | `diagram.png`    | 450         | 2025-01-25 12:00:00 | png       |

### **3. Удаление изображений**

**Описание:**

- добавить возможность удаления изображений через веб-интерфейс;

- реализовать маршрут `/delete/<id>`:

  - удаляет запись об изображении из базы данных;
  - удаляет физический файл из папки `/images`.

**Требования** 

- Каждое изображение в списке `/images-list` должно иметь кнопку "Удалить".
- При нажатии на кнопку происходит запрос к маршруту `/delete/<id>`, где `<id>` — идентификатор изображения.
- После успешного удаления: 
  - запись удаляется из базы PostgreSQL.
  - физический файл удаляется с диска.
  - пользователь перенаправляется обратно на `/images-list` с обновленным списком.

**Пример SQL-запроса для удаления записи:**

```sql
DELETE FROM images WHERE id = <id>;
```

### **4. Пагинация списка изображений**

Напомним, пагинация — это разделение большого объема информации на отдельные страницы. 
Представьте книгу — было бы неудобно читать её как один длинный свиток. 
То же самое и с данными на веб-странице. Если у нас 1000 изображений, показывать их все сразу будет сложно. 
Это тяжело для браузера, будет долго загружаться, ну а пользователю будет попросту неудобно читать. 

Поэтому мы разбиваем список на страницы, например по 10 элементов.

**Описание:**

- если список изображений длинноват, его нужно разделить на страницы.

- реализовать пагинацию на странице  `/images-list`:

  - отображать по 10 изображений на одной странице.
  - добавить кнопки "Следующая страница" и "Предыдущая страница".

**Требования**

- Использовать `LIMIT` и `OFFSET`  в SQL-запросах:

  ```sql
  SELECT * FROM images ORDER BY upload_time DESC LIMIT 10 OFFSET <смещение>;
  ```

- На веб-странице добавить навигацию для перехода между страницами:

  - например, `/images-list?page=2`.

- Убедиться, что пагинация корректно работает при малом количестве изображений или достижении конца списка.

### **5. Резервное копирование данных**

**Описание:**

- добавить возможность создавать резервные копии базы данных PostgreSQL;
- создать команду, которую можно запускать вручную для создания резервной копии.

**Требования**

- использовать встроенные инструменты PostgreSQL (`pg_dump`) для создания бэкапа;

- команда для создания резервной копии:

  ```bash
  docker exec -t postgres_container pg_dump -U postgres dbname > backup.sql
  ```

- сохраненные файлы резервных копий хранятся в папке `/backups`;

- Создать скрипт Python или shell-скрипт для автоматизации бэкапа:


Бэкап сохраняется с указанием даты и времени:

```bash
backup_2025-01-24_153000.sql
```

- добавить инструкцию в документацию по выполнению резервного копирования.



## **3. Обновленная структура проекта**

**Новые файлы и папки:**

```
project/
├── app.py                # Python-бэкенд
├── requirements.txt      # Зависимости Python
├── Dockerfile            # Dockerfile для Python-бэкенда
├── compose.yaml          # Конфигурация Docker Compose
├── nginx.conf            # Конфигурация Nginx
├── images/               # Папка для хранения загруженных изображений (volume)
├── logs/                 # Папка для логов (volume)
├── backups/              # Папка для хранения резервных копий
└── static/               # Статические файлы (CSS/JS)
```



## **4. Технические задачи**

1. **Настройка PostgreSQL:**
   - добавить PostgreSQL как новый сервис в `compose.yaml`;
   - настроить подключение Python-бэкенда к базе данных через библиотеку `psycopg2`.
2. **Модификация бэкенда:**
   - Реализовать маршруты для работы с базой данных:
     - `/images-list` для отображения списка изображений;
     - `/delete/<id>` для удаления изображений.
   - Дополнить обработку загрузки изображений для сохранения метаданных в базе.
3. **Реализация пагинации:**
   - добавить логику обработки параметров `page` в запросах;
   - Реализовать соответствующую SQL-логику с использованием `LIMIT` и `OFFSET`.
4. **Резервное копирование:**
   - добавить автоматический скрипт или инструкцию для создания резервных копий базы данных.
5. **Обновление интерфейса:**
   - добавить HTML для отображения списка изображений с кнопками удаления и пагинации.



## 5. Подключение базы данных

### **Этапы реализации**

1. Настроить PostgreSQL через Docker Compose.
2. Создать таблицу `images` для хранения метаданных.
3. Реализовать подключение Python-бэкенда к базе данных.
4. Дополнить обработку загрузки файлов логикой сохранения метаданных в PostgreSQL.
5. Протестировать корректность записи метаданных и обработки ошибок.

### Настройка PostgreSQL через Docker Compose

Пример как это может выглядеть:

```yaml
services:
  db:
    image: postgres:latest
    environment:
      POSTGRES_DB: images_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data
volumes:
  db_data:
```


### Создание таблицы `images` для хранения метаданных

**Создание таблицы `images` в PostgreSQL:**

Таблица должна быть создана с использованием следующей структуры:

```sql
CREATE TABLE images (
    id SERIAL PRIMARY KEY,               -- Уникальный идентификатор записи
    filename TEXT NOT NULL,              -- Уникальное имя файла (сгенерированное)
    original_name TEXT NOT NULL,         -- Оригинальное имя файла (пользователя)
    size INTEGER NOT NULL,               -- Размер файла в байтах
    upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Время загрузки файла
    file_type TEXT NOT NULL              -- Формат файла (jpg, png, gif и т.д.)
);
```

Поля таблицы:

- **`id`**: автоматически генерируемый уникальный идентификатор для каждого изображения.
- **`filename`**: уникальное имя файла, сгенерированное сервером.
- **`original_name`**: имя файла, отправленное пользователем.
- **`size`**: размер файла в байтах.
- **`upload_time`**: дата и время загрузки файла.
- **`file_type`**: формат файла (например, `jpg`, `png`).

### Подключение Python-бэкенда к базе данных.

**Подключение к базе данных PostgreSQL:**

- используйте библиотеку `psycopg2` для взаимодействия с PostgreSQL.

- настройте подключение через параметры:

  - хост (например, `db`, если используется Docker Compose).
  - порт (по умолчанию `5432`).
  - имя базы данных, пользователь и пароль.


Пример подключения:

```python
import psycopg2

conn = psycopg2.connect(
    dbname="images_db",
    user="postgres",
    password="password",
    host="db",
    port="5432"
)
cursor = conn.cursor()
```

### Добавление данных в PostgreSQL

**Добавление записи в базу данных:**

Реализовать функцию для сохранения метаданных:

```python
def save_metadata(filename, original_name, size, file_type):
    query = """
    INSERT INTO images (filename, original_name, size, file_type)
    VALUES (%s, %s, %s, %s)
    """
    cursor.execute(query, (filename, original_name, size, file_type))
    conn.commit()
```
Эта функция вызывается после успешного сохранения файла на сервере.

### Тестирование подключения к базе

Перед использованием базы данных, необходимо протестировать подключение:

```python
def test_connection():
    try:
        conn = psycopg2.connect(
            dbname="images_db",
            user="postgres",
            password="password",
            host="db",
            port="5432"
        )
        print("Соединение с базой данных успешно")
    except Exception as e:
        print(f"Ошибка подключения: {e}")
```


## 6. Критерии успешности

За проект "Сервер картинок 2.0" можно получить максимум 50 баллов.

### **1. Хранение метаданных об изображениях в базе данных** (20 балов)

1. **Таблица `images` создана и функционирует корректно:**
   - поля соответствуют требованиям (уникальный ID, имя файла, оригинальное имя, размер, формат, дата загрузки);
   - метаданные каждого изображения успешно сохраняются в базу данных при загрузке файла;
   - уникальное имя файла генерируется сервером;
   - данные из таблицы доступны для последующего использования в других функциях проекта.
2. **Обработка ошибок:**
   - при ошибке подключения к базе данных или невозможности записи метаданных файл не сохраняется на сервере;
   - все ошибки логируются в файл `app.log` с указанием причины.
3. **Валидация:**
   - метаданные корректно сохраняются в базе данных при загрузке файлов разных форматов (`jpg`, `png`, `gif`) и размеров;
   - логика обработки исключений работает без сбоев.

#### **2. Добавление страницы списка изображений (10 баллов)**

1. **Страница `/images-list` отображает список загруженных изображений:**
   - таблица содержит информацию о каждом изображении:
     - имя файла (ссылка для скачивания/просмотра);
     - оригинальное имя;
     - размер файла (в КБ);
     - дата и время загрузки;
     - тип файла.
   - Сортировка по дате загрузки (последние загруженные изображения отображаются первыми).
2. **Навигация по списку:**
   - если список содержит более 10 записей, он разбивается на страницы;
   - пагинация реализована корректно:
     - отображаются кнопки "Следующая страница" и "Предыдущая страница";
     - переход между страницами происходит без ошибок.
3. **Доступность данных:**
   - ссылки на файлы ведут к корректным маршрутам (`/images/<имя_файла>`);
   - если данных в базе нет, отображается сообщение "Нет загруженных изображений".
4. **Дизайн страницы:**
   - таблица оформлена с использованием CSS, данные легко читаемы;
   - кнопки навигации расположены интуитивно.

#### **3. Удаление изображений (5 баллов)**  

1. **Функция удаления работает корректно:**
   - каждое изображение в списке `/images-list` имеет кнопку "Удалить";
   - при нажатии на кнопку:
     - запись об изображении удаляется из базы данных;
     - физический файл удаляется из папки `/images`.
2. **Обновление страницы:**
   - после удаления пользователь перенаправляется обратно на страницу `/images-list`, и список обновляется.
3. **Обработка ошибок:**
   - если изображение с указанным ID не найдено в базе данных, возвращается корректное сообщение об ошибке;
   - все действия логируются:
     - успешное удаление;
     - ошибки (например, файл отсутствует на диске).

#### **4. Пагинация списка изображений** (5 баллов)

1. **Работа пагинации:**

   - список изображений корректно разделяется на страницы, по 10 записей на каждой;
   - переходы между страницами работают корректно:
     - записи обновляются в соответствии с номером страницы;
     - доступны кнопки "Следующая страница" и "Предыдущая страница".

2. **Граничные случаи:**

   - при достижении последней страницы кнопка "Следующая страница" отключается;
   - если на первой странице нет предыдущих данных, кнопка "Предыдущая страница" отключается.

3. **SQL-запросы:**

   - используются LIMIT и OFFSET  для выборки данных из базы PostgreSQL:

     ```sql
     SELECT * FROM images ORDER BY upload_time DESC LIMIT 10 OFFSET <смещение>;
     ```

#### **5. Резервное копирование данных (5 баллов)** 

1. **Сохранение резервной копии базы данных:**

   - создана команда для резервного копирования базы данных PostgreSQL:

     ```bash
     docker exec -t postgres_container pg_dump -U postgres images_db > backups/backup_<дата_и_время>.sql
     ```

   - бэкап сохраняется с указанием даты и времени (например, `backup_2025-01-24_153000.sql`).

   - все резервные копии хранятся в папке `/backups`.

2. **Скрипт для автоматизации:**

   - реализован Python-скрипт или shell-скрипт, который автоматически создает резервную копию по расписанию или при запуске команды.

3. **Инструкции:**

   - написана документация, описывающая процесс резервного копирования;

   - включены шаги для восстановления базы данных из резервной копии:

     ```bash
     docker exec -i postgres_container psql -U postgres images_db < backup.sql
     ```

#### **6. Общее (5 баллов)**

1. **Проект запускается и работает через Docker Compose:**

   - Команда запуска:

     ```bash
     docker compose up --build
     ```

   - Все зависимости и конфигурации включены в проект.

2. **Логирование:**

   - Все действия (загрузка, удаление, резервное копирование) логируются в файл `app.log` с указанием даты, времени и результата операции.

3. **Документация:**

   - Подробное описание всех маршрутов, функциональности и процесса резервного копирования включено в документацию.

