## Нормальная форма Бойса — Кодда (BCNF)

**Нормальная форма Бойса — Кодда (BCNF)** — это более строгая версия третьей нормальной формы (3NF), которая устраняет все виды функциональных зависимостей, выходящих за пределы потенциальных ключей. В BCNF, если существует функциональная зависимость X→Y, то атрибуты X должны составлять потенциальный ключ.

Давайте рассмотрим пример, который удовлетворяет 1NF, 2NF, и 3NF, но противоречит BCNF.

Для этого мы создадим таблицу, где функциональная зависимость нарушает правило BCNF, хотя таблица еще будет соответствовать первым трем нормальным формам.
Пример

| StudentID | CourseID | InstructorName | Grade |
|-----------|----------|----------------|-------|
| 1         | 101      | Dr. Smith      | A     |
| 1         | 102      | Dr. Johnson    | B     |
| 2         | 101      | Dr. Smith      | A     |
| 2         | 103      | Dr. Brown      | C     |

Проверим соответствие первым трем нормальным формам:
1NF (Первая нормальная форма):

Таблица удовлетворяет 1NF, так как все данные атомарны (каждая ячейка содержит только одно значение).
2NF (Вторая нормальная форма):

Таблица удовлетворяет 2NF, так как:

    Все неключевые атрибуты (InstructorName, Grade) полностью зависят от всего первичного ключа (StudentID, CourseID).
    Нет частичных зависимостей, так как каждый неключевой атрибут зависит от всей комбинации ключа.

3NF (Третья нормальная форма):

Таблица удовлетворяет 3NF, так как:

    Все неключевые атрибуты (InstructorName, Grade) зависят только от ключа (StudentID, CourseID).
    Нет транзитивных зависимостей (InstructorName зависит только от CourseID, и это не транзитивная зависимость).

Анализ по BCNF:

Разбор функциональной зависимости

Функциональная зависимость:
    CourseID → InstructorName.
    Это означает, что для каждого CourseID (идентификатора курса) однозначно определяется преподаватель (InstructorName). Например, курс с CourseID = 101 всегда преподает Dr. Smith, курс с CourseID = 102 — Dr. Johnson, и так далее.

Почему это нарушает BCNF?

    В BCNF говорится, что для каждой функциональной зависимости X → Y в таблице, X должно быть потенциальным ключом (или суперклавишем). 
    Это означает, что X должно быть уникальным идентификатором для каждой строки таблицы.

    В нашем примере:
        StudentID и CourseID вместе составляют первичный ключ таблицы, потому что комбинация этих двух атрибутов уникально идентифицирует каждую строку.
        Однако, CourseID → InstructorName предполагает, что для каждого CourseID однозначно определяется InstructorName.
        но CourseID сам по себе не является уникальным идентификатором.
        Один и тот же курс может преподаваться нескольким студентам (например, курс Math может преподаваться нескольким студентам).

    Согласно BCNF, CourseID должен быть потенциальным ключом, но это не так. 
    CourseID не уникален в контексте всей таблицы, потому что для одного и того же курса могут быть несколько студентов, 
    получающих разные оценки.

Решение для приведения таблицы в BCNF:

    Чтобы устранить нарушение BCNF, нам нужно разделить таблицу таким образом, чтобы функциональная зависимость CourseID → InstructorName находилась в отдельной таблице, где CourseID станет ключом.

Разделение таблицы
1. Таблица для курсов и преподавателей:

| CourseID | InstructorName |
|----------|----------------|
| 101      | Dr. Smith      |
| 102      | Dr. Johnson    |
| 103      | Dr. Brown      |

Здесь CourseID является уникальным ключом, и функциональная зависимость CourseID → InstructorName удовлетворяет BCNF, так как CourseID теперь является ключом.
2. Таблица для студентов, курсов и оценок:

| StudentID | CourseID | Grade |
|-----------|----------|-------|
| 1         | 101      | A     |
| 1         | 102      | B     |
| 2         | 101      | A     |
| 2         | 103      | C     |

Здесь StudentID и CourseID вместе составляют первичный ключ, и все функциональные зависимости удовлетворяют BCNF, так как ни один из детерминантов не является частью составного ключа.
Итог:

В исходной таблице CourseID нарушает BCNF, потому что он определяет InstructorName, но сам по себе не является ключом. После разделения таблицы, каждая из новых таблиц соответствует BCNF, так как все функциональные зависимости теперь имеют детерминанты, являющиеся потенциальными ключами.